/* show dataset */
SELECT *FROM tableRetail
WHERE ROWNUM <= 10;

SELECT 
Distinct TO_CHAR(TO_DATE(INVOICEDATE, 'MM/DD/YYYY HH24:MI'), 'YYYY-MM') AS InvoiceYearMonth
FROM tableRetail


/* Check for duplication */ 
SELECT *
FROM tableRetail
WHERE ROWID NOT IN (
    SELECT MIN(ROWID)
    FROM tableRetail
    GROUP BY invoice,Stockcode,Quantity,Price,Customer_ID,INVOICEDATE,Country 
);

/* Data expolaration */ 

/*Top customers by total spending
This query can help identify the most valuable customers in terms of revenue generation, and can be used to create targeted marketing campaigns or loyalty programs for these customers.
*/  
  SELECT 
  Distinct Customer_ID, 
  SUM(Quantity * Price) OVER (PARTITION BY Customer_ID) AS Total_Spending
FROM 
  tableRetail
WHERE 
  Customer_ID IS NOT NULL
ORDER BY 
  Total_Spending DESC

/* monthly revenue trend
This query can help identify the revenue trend over time and can be used to adjust business strategies to capitalize on seasonal trends and demand.
*/ 
SELECT  TO_CHAR(TO_DATE(INVOICEDATE, 'MM/DD/YYYY HH24:MI'), 'YYYY-MM') AS MONTH,
       SUM(QUANTITY*PRICE) AS REVENUE
FROM  tableRetail
GROUP BY  TO_CHAR(TO_DATE(INVOICEDATE, 'MM/DD/YYYY HH24:MI'), 'YYYY-MM') 
ORDER BY  TO_CHAR(TO_DATE(INVOICEDATE, 'MM/DD/YYYY HH24:MI'), 'YYYY-MM');
/* find the top 10 customers with the highest average order value 
This query can help identify the most valuable customers in terms of average order value, and can be used to create targeted marketing campaigns or loyalty programs for these customers.
*/ 
SELECT Customer_ID, AVG(OrderValue) AS AvgOrderValue
FROM (
  SELECT DISTINCT Customer_ID, Price * Quantity AS OrderValue
  FROM tableRetail
) t
GROUP BY Customer_ID
ORDER BY AVG(OrderValue) DESC
FETCH FIRST 10 ROWS ONLY;

/*Query to find the percentage of revenue generated by the top 10 products
This query can help identify the most important products in terms of revenue generation, and can be used to make informed decisions about inventory management, product pricing, and marketing strategies.
*/
SELECT 
    Stockcode, 
    SUM(Price * Quantity) AS TotalRevenue, 
    SUM(Price * Quantity) / SUM(SUM(Price * Quantity)) OVER () * 100 AS RevenuePercentage
FROM 
    tableRetail
GROUP BY 
    Stockcode, 
    Price
ORDER BY 
    TotalRevenue DESC 
FETCH FIRST 10 ROWS ONLY;

/* find the most popular products by quantity sold 
This query can help identify the most popular products and can be used to make informed decisions about inventory management, product pricing, and marketing strategies.
*/
SELECT Stockcode, TotalQuantitySold 
FROM (
  SELECT Stockcode, SUM(Quantity) AS TotalQuantitySold, 
         ROW_NUMBER() OVER (PARTITION BY SUM(Quantity) ORDER BY Stockcode) AS rn
  FROM tableRetail
  GROUP BY Stockcode
) t
WHERE rn = 1
ORDER BY TotalQuantitySold DESC;

/* ----------------------------------------------- */ 

-- Create a temporary table called customer_data
WITH customer_data AS (
    -- Select customer_id, most recent date, number of invoices, total sales, r_score, and fm_score
    SELECT customer_id,
           MAX(INVOICEDATE) AS Most_recent_date,
           COUNT(DISTINCT invoice) AS Num_invoices,
           SUM(Quantity * Price) AS Total_sales,
           CASE
               -- Assign r_score based on the number of invoices made by the customer
               WHEN COUNT(DISTINCT invoice) <= 1 THEN 1
               WHEN COUNT(DISTINCT invoice) <= 3 THEN 2
               WHEN COUNT(DISTINCT invoice) <= 6 THEN 3
               WHEN COUNT(DISTINCT invoice) <= 9 THEN 4
               ELSE 5
           END AS r_score,
           -- Assign row_num to each customer based on Most_recent_date in descending order
           ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY MAX(INVOICEDATE) DESC) AS row_num,
           -- Assign fm_score based on the total sales made by the customer
           CASE
               WHEN COUNT(DISTINCT invoice) = 1 THEN 1
               WHEN SUM(Quantity * Price) <= 1000 THEN 2
               WHEN SUM(Quantity * Price) <= 5000 THEN 3
               WHEN SUM(Quantity * Price) <= 10000 THEN 4
               ELSE 5
           END AS fm_score
    -- Group data by customer_id
    FROM tableretail
    GROUP BY customer_id
),
-- Create a temporary table called customer_recency
customer_recency AS (
    -- Select customer_id and calculate Recency, which is the number of seconds since the customer's most recent purchase
    SELECT customer_id,
           ROUND((TO_DATE('25-04-2022', 'DD-MM-YYYY') - TO_DATE(MAX(INVOICEDATE), 'MM-DD-YYYY HH24:MI')) * 86400) AS Recency
    FROM tableretail
    GROUP BY customer_id
)
-- Join customer_data and customer_recency and select relevant columns to create the final result set
SELECT cd.customer_id,
       cd.Most_recent_date,
       cr.Recency,
       cd.Num_invoices AS Frequency,
       cd.Total_sales AS Monetary,
       cd.r_score,
       cd.fm_score,
       -- Assign customer segments based on customer behavior
       CASE
           WHEN cd.Num_invoices >= 10 AND cd.Total_sales >= 10000 THEN 'Champions'
           WHEN cd.Num_invoices >= 6 AND cd.Total_sales >= 5000 THEN 'Loyal Customers'
           WHEN cd.Num_invoices >= 3 AND cd.r_score >= 4 THEN 'Potential Loyalists'
           WHEN cd.Num_invoices >= 1 AND cd.r_score >= 3 THEN 'Recent Customers'
           WHEN cd.Num_invoices >= 1 AND cd.fm_score = 1 THEN 'Promising'
           WHEN cd.Num_invoices >= 1 AND cd.fm_score = 2 THEN 'Customers Needing Attention'
           WHEN cd.Num_invoices <= 2 AND cd.r_score < 3 AND cd.fm_score >= 3 THEN 'At Risk'
           WHEN cd.Num_invoices <= 2 AND cd.r_score < 3 AND cd.fm_score < 3 THEN 'Cant Lose Them'
           WHEN cd.Num_invoices = 1 AND cd.r_score = 1 AND cd.fm_score = 5 THEN 'Hibernating'
           ELSE 'Lost'
       END AS customer_segment
FROM customer_data cd
JOIN customer_recency cr ON cd.customer_id = cr.customer_id
-- Select only the most recent record for each customer
WHERE cd.row_num = 1;


/* Q3 */ 
-- What is the maximum number of consecutive days a customer made purchases?

-- Use a common table expression (CTE) to rank each transaction by customer and date
WITH ranked_transactions AS (
  SELECT
    cust_id,
    calendar_dt,
    ROW_NUMBER() OVER (PARTITION BY cust_id ORDER BY calendar_dt) AS rn
  FROM
    transactions
),
-- Calculate the difference between each date and its rank to group consecutive dates together
consecutive_transactions AS (
  SELECT
    cust_id,
    calendar_dt,
    calendar_dt - rn AS grp
  FROM
    ranked_transactions
)
-- Group by customer and date group to count the number of consecutive days for each customer
SELECT
  cust_id,
  COUNT(*) AS Max_consecutive_days 
FROM
  consecutive_transactions
GROUP BY
  cust_id,
  grp
ORDER BY
  Max_consecutive_days DESC;
  
  --On average, How many days/transactions does it take a customer to reach a spent  threshold of 250 L.E?
  
SELECT ROUND(AVG((Threshold_Date - Start_Date)),0) AS Avg_Days_To_Threshold
FROM (
  SELECT Cust_Id, MIN(Calendar_Dt) AS Start_Date,
    MIN(CASE WHEN Amt_LE >= 250 THEN Calendar_Dt END) AS Threshold_Date
  FROM transactions
  GROUP BY Cust_Id
  HAVING COUNT(CASE WHEN Amt_LE >= 250 THEN 1 END) > 0
) t;

